# Alternate view of the bundle, where each request is a key in an object as opposed
# to an array of requests. If we have an array, the outline is not convenient. It also
# makes us add extra validation for unique names of requests. The alternative is to build
# our own outline view where we show the requests and let users either navigate to that in the yaml
# and execute, or execute from the outline view itself using a context menu.

# But this approach fits into our manifesto/philosophy of reusing existing stuff. The only
# downside is that we can't add CodeLens using regexes. We will need to parseDocument the yaml
# or move the execution trigger to a context menu (or an action button, not sure if it is possible)
# in the outline view. Or some other TreeView that we can add on the sidebar (like thunderclient)

common:
  baseUrl: https://postman-echo.com
  headers:
    - { name: Content-type, value: application/json }
  options:
    follow: false    # the default, so this can be omitted
    verifySSL: false # the default, so this can be omitted
  tests:
    status: 200
    headers:
      Content-type: application/json; charset=utf-8

requests:

  simple-get: { method: GET, url: /simpleget }

  get-with-params:
    method: GET
    url: /get
    params:
      - { name: foo1, value: bar1 }
      - { name: foo2, value: bar2 }
    tests:
      json: { $.args.foo1: bar1,  $.args.foo2: bar2 }

  post-header-merge:
    url: /post
    method: POST
    headers: 
      - { name: X-Custom-Header, value: Custom Value }
    body: |-
      {
        "foo1": "bar1",
        "foo2": 42
      }
    tests:
      json: { $.data.foo1: bar1,  $.data.foo2: { $type: number, $gt: 41, $lt: 43 } }
      headers: { X-Custom-Header: Custom Value }

  post-header-override:
    url: /post
    method: POST
    headers: 
      - { name: Content-Type, value: text/plain }
    body: { foo: bar }
    tests:
      json: { $.data: "{ foo bar }" }

  status-404:
    url: /notfound
    method: GET
    tests: { status: 404 }

  status-401:
    url: /status/401
    method: GET
    tests: { status: 401, { json: { $.status: 401 } } }

  encoding:
    method: GET
    url: /get
    params:
      - { name: foo, value: 30% of 200 is 60 }
    tests:
      json:
        $.url: https://postman-echo.com/get?foo=30%25%20of%20200%20is%2060
        $.args.foo: 30% of 200 is 60

  no-encoding:
    method: GET
    url: /get
    params:
      - { name: foo, value: 30%25+of+200, encode: false }
    tests:
      json:
        $.url: https://postman-echo.com/get?foo=30%25%+of%+200
        $.args.foo: 30% of 200

  # The cookies endpoint does a redirect (no clue why), let's use that.
  no-redirects:
    method: GET
    url: /cookies/set
    tests:
      status: 302
      headers: { Location: /cookies,  Content-Type: { $ne: application/json } }

  redirects:
    options:
      follow: true
    method: GET
    url: /cookies/set
    tests:
      # code: 200 - this is inherited from common
      json: { $.cookies: { $exists: true } } # Header names are case insensitive

  non-json:
    method: GET
    url: /encoding/utf8
    tests:
      body: { $regex: unicode demo, $options: i }

  response-headers:
    method: GET
    url: /response-headers
    params:
      - { name: foo, value: bar }
    tests: { headers: { foo: bar } }

  override-base-url:
    method: GET
    url: https://postman-echo.com/get

  variables-in-params:
    method: GET
    url: $(getUrl)
    params:
      - { name: replaced1, value: $username }
      - { name: replaced2, value: some$myUsername }
      - { name: replaced3, value: some$(myUsername)else }
      - { name: verbatim1, value: $usernameelse }
      - { name: verbatim2, value: \$(username) }
    tests:
      json:
        $.args.replaced1: vasan.subramanian
        $.args.replaced2: somevasan.subramanian
        $.args.replaced3: somevasan.subramanianelse
        $.args.verbatim1: { $ne: vasan.subramaniansome, $eq: $usernameelse }
        $.args.verbatim2: { $ne: vasan.subramanian, $eq: \$(username) }

  variables-in-headers:
    method: GET
    url: $(getUrl)
    headers:
      - { name: foo, value: $(fooValue) }
    tests: { json: { $.headers.foo: bar } }

  variables-in-body:
    method: POST
    url: /post
    body: |-
      {
        "foo1": "$(fooValue)",
        "foo2": $pi
      }
    tests:
      json: { $.data.foo1: bar,  $.data.foo2: { $type: number, $eq: 3.414 } }

  test-tests-positive:
    method: POST
    url: /post
    body: |-
      {
        "firstName": "John",
        "lastName": "Doe",
        "middleName": null,
        "age": 26,
        "address": {
            "streetAddress": "naist street",
            "city": "Nara",
            "postalCode": "560034"
        },
        "phoneNumbers": [
            {
                "type": "mobile",
                "number": "0123-4567-8888",
                "available": [ 7, 22 ]
            },
            {
                "type": "home",
                "number": "0123-4567-8910",
                "available": [ 18, 22 ]
            }
        ]
      }
    tests:
      json:
        $.data.firstName: John
        $.data.age: { $type: number, $eq: 26, $ne: "26" }
        $.data.address: { $type: object, $size: 3, $exists: true }
        $.data.address.city: Nara
        $.data.address.postalCode: { $type: string, $size: 6, $ne: 560034 }
        $.data.phoneNumbers: { $type: array, $size: 2, $exists: true }
        $.data.phoneNumbers[0].type: mobile
        $.data.phoneNumbers.0.type: mobile
        $.data.phoneNumbers[?(@.type=="home")].number: "0123-4567-8910"
        $.data.lastName: { $exists: true }
        $.data.middleName: { $exists: true, $type: null }
        $.data.otherName: { $exists: false }
        $.data.phoneNumbers[*].type: '["mobile","home"]'
        $.data.phoneNumbers[*].available: '[[7,22],[18,22]]'
        # stress: ensure corner cases don't crash
        $.data.otherName.value: { $exists: false } # don't recurse down undefined
        

  # All these tests should fail
  test-tests-negative:
    method: POST
    url: /post
    body: |-
      {
        age: 26
        name: John
        numbers: [ 1, 2 ]
      }
    tests:
      json:
        $.data.name: { $type: array }
        $.data.missing: { $size: 0, $exists: true } # should report 2 failures
        $.data.missing.missing.missing: { $exists: true }
        $.data.numbers.0: "1" # "1" is not same as 1. We use === for $eq and !== for $neq

        # stress: ensure corner cases don't crash
        $.data.age: { $size: 2 }  # .length not supported for type: number
        $.data.operator: { $badop: any }  # invalid operator
        $.data.values: { $ne: [1, 2] } # invalid assertion value, expecitng a scalar
        $.data.value: { $ne: { nonesting: any } } # invalid assertion value, expecting a scalar
        $.data.numbers: { $size: two } # invalid assertion value, expecting a number
        $.data.exists: { $exists: 4 } # invalid assertion value, expecitng a boolean
        $.data.numbers[?(.@)]: 4 # invalid path
        
  extra-test:
    method: GOT
    url: https://test-farmerapp.agrostar.in/userservice/ping/
    tests: 
      headers:
        Content-type: application/json
